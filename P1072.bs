<pre class='metadata'>
Title: Optimized Initialization for basic_string
Status: P
Shortname: P1072
Group: WG21
Revision: 2
Editor: Chris Kennelly, Google, ckennelly@google.com
Editor: Mark Zeren, VMware, mzeren@vmware.com
Date: 2018-11-08
Audience: LEWG
Audience: LWG
Audience: SG16
Abstract: Allow access to uninitialized or default initialized elements when working with basic_string
URL: http://wg21.link/P1072R2
Markup Shorthands: markdown yes
Default Highlight: C++
</pre>

# Motivation # {#mot}

Performance sensitive code is impacted by the cost of initializing and
manipulating strings: When streaming data into a `basic_string`, a
programmer is forced with an unhappy choice:

* **Pay for extra initialization** &mdash; `resize`, which zero
    initializes, followed by copy.

* **Pay for extra copies** &mdash; Populate a temporary buffer, copy
    it to the string.

* **Pay for extra "bookkeeping"** &mdash; `reserve` followed by small
    appends, each of which checks capacity and null terminates.

The effects of these unhappy choices can all be measured at scale.
C++'s hallmark is to leave no room between the language (or in this
case the library) and another language. This proposal closes that gap
for `basic_string` by creating a mechanism to access `basic_string`'s
buffer without value initializing its contents.

LEWGI polled on this at the [[SAN]] Meeting:

<blockquote>
We should promise more commitee time to [[P1072R1]], knowing that our
time is scarce and this will leave less time for other work?
<br/>*Unanimous consent*
</blockquote>

LEWG at the [[SAN]] Meeting:

<blockquote>
We want to solve this problem
<table>
<tr><th>SF</th><th>F</th><th>N</th><th>A</th><th>SA</th></tr>
<tr><td>17</td><td>5</td><td>0</td><td>0</td><td>0</td></tr>
</table>
</blockquote>

## Stamping a Pattern ## {#pattern}

Consider writing a pattern several times into a string:
<xmp>
std::string GeneratePattern(const std::string& pattern, size_t count) {
   std::string ret;

   ret.reserve(pattern.size() * count);
   for (size_t i = 0; i < count; i++) {
     // SUB-OPTIMAL:
     // * Writes 'count' nulls
     // * Updates size and checks for potential resize 'count' times
     ret.append(pattern);
   }

   return ret;
}
</xmp>

Alternatively, we could adjust the output stringâ€™s size to its final size,
avoiding the bookkeeping in `append` at the cost of extra initialization:
<xmp>
std::string GeneratePattern(const std::string& pattern, size_t count) {
   std::string ret;

   const auto step = pattern.size();
   // SUB-OPTIMAL: We memset step*count bytes only to overwrite them.
   ret.resize(step * count);
   for (size_t i = 0; i < count; i++) {
     // GOOD: No bookkeeping
     memcpy(ret.data() + i * step, pattern.data(), step);
   }

   return ret;
}
</xmp>

We propose `basic_string::resize_uninitialized` to avoid this tradeoff.

<xmp>
std::string GeneratePattern(const std::string& pattern, size_t count) {
   std::string ret;

   const auto step = pattern.size();
   // GOOD:  No initialization
   ret.resize_uninitialized(step * count);
   for (size_t i = 0; i < count; i++) {
     // GOOD: No bookkeeping
     memcpy(ret.data() + i * step, pattern.data(), step);
   }

   return ret;
}
</xmp>

## Interacting with C ## {#c}

Consider wrapping a C API while working in terms of C++'s `basic_string`
vocabulary.  We *anticipate* overallocating, as computation of the *length* of
the data is done simultaneously with the computation of the *contents*.

<xmp>
extern "C" {
  int compress(void* out, size_t* out_size, const void* in, size_t in_size);
  size_t compressBound(size_t bound);
}

std::string CompressWrapper(std::string_view input) {
    std::string compressed;
    // Compute upper limit of compressed input.
    size_t size = compressBound(input.size());

    // SUB-OPTIMAL:  Extra initialization
    compressed.resize(size);
    int ret = compress(compressed.begin(), &size, input.data(), input.size());
    if (ret != OK) {
      throw ...some error...
    }

    // Shrink compress to its true size.
    compress.resize(size);
    return compressed;
}
</xmp>

With the proposed `resize_uninitialized`:

<xmp>
extern "C" {
  int compress(void* out, size_t* out_size, const void* in, size_t in_size);
  size_t compressBound(size_t bound);
}

std::string CompressWrapper(std::string_view input) {
    std::string compressed;
    // Compute upper limit of compressed input.
    size_t size = compressBound(input.size());

    // GOOD:  No initialization
    compressed.resize_uninitialized(size);
    int ret = compress(compressed.begin(), &size, input.data(), input.size());
    if (ret != OK) {
      throw ...some error...
    }

    // Shrink compress to its true size.
    compress.commit(size);
    return std::string(std::move(compressed));
}
</xmp>

# Proposal # {#prop}

Wording relative to [[N4778]]

Add to basic.string.capacity [24.3.2.4]:

<ins>
<xmp>
void resize_uninitialized(size_type n);
</xmp>

*   *Throws*: `length_error` if `n > max_size()`
*   *Effects*:  Alters the length of the string designated by `*this` as follows:

    *   If `n <= size()`, calls `resize(n)`
    *   If `n > size()`, the function replaces the string designated by `*this` with a string of length `n` whose first `size()` elements are a copy of the original string designated by `*this`, and whose remaining elements are default initialized.

</ins>

The "null terminator" invariant of `basic_string` [24.3.2] is unchanged.

## Design Considerations ## {#design}

### Method vs. Standalone "Buffer" Type

During the [[SAN]] Meeting, LEWG expressed a preference for implementing
this as a new method on `basic_string` (as proposed in [[P1072R0]]) rather than a
standalone "storage buffer" type:

<blockquote>
Method on string vs storage_buffer type:
<table>
<tr><th>Strong Method</th><th>Method</th><th>Neutral</th><th>Type</th><th>Strong Type</th></tr>
<td>9</td><td>2</td><td>3</td><td>2</td><td>2</td></tr>
</table>
</blockquote>


### Tag type vs. Method Name

TODO


### Analysis Tools

Analysis tools which base their analysis on the `size()` of the string
will be weakend by this proposal.

Dynamic analysis tools which track uninitialized state of memory, such
as Valgrind and Memory Sanitizer (TODO add references) will be abel to
diagnose reads from uninitialized elements of the string.


## Bikeshedding ## {#bikeshed}

What do we want to call this method?

*   `resize_uninitialized` (as proposed)
*   `resize_default_init` (for consistency with [[P1020R1]], adopted in San Diego Meeting)

# Alternatives Considered # {#alternatives}

## Tag Type ## {#tag}

At the [[SAN]] Meeting, LEWG showed indifference between the
`resize_uninitialized` approach proposed in this paper and a "tag type"
style solution:

<xmp>
std::string GeneratePattern(const std::string& pattern, size_t count) {
   std::string ret;

   const auto step = pattern.size();
   // GOOD:  No initialization
   ret.resize(step * count, std::string::default_init);
   for (size_t i = 0; i < count; i++) {
     // GOOD: No bookkeeping
     memcpy(ret.data() + i * step, pattern.data(), step);
   }

   return ret;
}
</xmp>

Benefits:
*   We could invoke the constructor with the tag type as well, potentially
    simplifying code needing this functionality.

Drawbacks:
*   [[P1010R1]] contemplates initialization optimization extensions to
    `vector`.  Unlike `basic_string`, `vector` is less constrained on its
    choices of types.  The similarities in initialization are appealing,
    but there are possible pitfalls around interactions with allocators
    and the types supported (do we cover [[P0593R2]] / [[P1144R0]] /
    etc.).

## Standalone Type:  `storage_buffer` ## {#buffer}

In [[P1072R1]], we considered `storage_buffer`, a standalone type
providing a `prepare` method (similar to the `resize_uninitialized` method
proposed here) and `commit` (to promise, under penalty of UB, that the
buffer had been initialized).

At the [[SAN]] Meeting, this approach received support from LEWGI in
light of the the [[post-Rapperswil]] email review indicating support for a
distinct type.  This approach was rejected by the larger LEWG room in San Diego Meeting
Diego.


The proposed type would be move-only.

<xmp>
std::string GeneratePattern(const std::string& pattern, size_t count) {
   std::storage_buffer<char> tmp;

   const auto step = pattern.size();
   // GOOD:  No initialization
   tmp.prepare(step * count + 1);
   for (size_t i = 0; i < count; i++) {
     // GOOD: No bookkeeping
     memcpy(tmp.data() + i * step, pattern.data(), step);
   }

   tmp.commit(step * count);
   return std::string(std::move(tmp));
}
</xmp>

For purposes of the container API, `size()` corresponds to the *committed*
portion of the buffer.  This leads to more consistency when working with (and
explicitly copying to) other containers via iterators, for example:

<xmp>
    std::storage_buffer<char> buf;
    buf.prepare(100);
    *fill in data*
    buf.commit(50);

    std::string a(buf.begin(), buf.end());
    std::string b(std::move(buf));

    assert(a == b);
</xmp>

Benefits:
*   By being move-only, we would not have the risk of copying types with
    trap representations (thereby triggering UB).
*   Uninitialized data is only accessible from the `storage_buffer` type.
    For an API working with `basic_string`, no invariants are weakened.
    Crossing an API boundary with a `storage_buffer` is much more obvious than
    a "`basic_string` with possibly uninitialized data."  Uninitialized bytes
    (the promise made by `commit`) never escape into the valid range of
    `basic_string`.

Drawbacks:
*   `storage_buffer` requires introducing an extra type to the standard
    library, even though its novel functionality (from `string` and
    `vector`) is limited to the initialization abilities.
*   `basic_string` is often implemented with a short-string optimization (SSO) and an extra type would need to implement that (likely by additional checks when moving to/from the `storage_buffer`) that are often unneeded.

## Externally-Allocated Buffer Injection ## {#external}

We asked whether we should accept an externally allocated and initialized `T*`
and place it into a `basic_string`.  At the [[SAN]] Meeting, we concluded that
this was:

*  **Not critical**
*  **Not constrained in the future**
*  **Could overly constrain implementers**.  Allowing users to provide their own `allocator::allocate`'d buffers runs into the "offset problem".  Consider an implementation that stores its `size` and `capacity` inline with its data, so `sizeof(vector) == sizeof(void*)`.

    <xmp>
    class container {
      struct Rep {
        size_t size;
        size_t capacity;
      };

      Rep* rep_;
    };
    </xmp>

    If using a `Rep`-style implementation, the mismatch in offsets
    requires an O(N) move to shift the contents into place and trigger a
    possible reallocation.

*  **Have usage pitfalls**.  It would be easy to mix `new[]` and `allocator::deallocate` inadvertently:

    <xmp>
    std::string GeneratePattern(const std::string& pattern, size_t count) {
        const auto step = pattern.size();

        // GOOD:  No initialization
        std::string ret;
        ret.reserve(step * count);

        auto tmp = ret.release();

        char* start = tmp.data();
        auto  size  = tmp.size();
        auto  cap   = tmp.capacity();
        tmp.release();

        for (size_t i = 0; i < count; i++) {
            // GOOD: No bookkeeping
            memcpy(start + i * step, pattern.data(), step);
        }

        return std::string(std::storage_node(
            tmp, size + count * step, cap, alloc));
    }
    </xmp>

    (It is important to reiterate that the above implementation is possible
    because we statically know that the allocator is `std::allocator` and that
    the `value_type` is `char`. A generic implementation of this pattern would
    need to be constrained based on allocators, allocator traits, and value
    types. Future library and language extensions may expand the set of
    applicable types and may make it easier to constrain generic
    implementations.)

# Related Work # {#related}

## Google ## {#google}

Google has a local extension to `basic_string` called `resize_uninitialized`
and is wrapped as `STLStringResizeUninitialized`.

*   [[Abseil]] uses this to avoid bookkeeping overheads in `StrAppend` and
    `StrCat`.
*   [[Snappy]]

    *   In <a href="https://github.com/google/snappy/blob/master/snappy.cc#L1318">decompression</a>, the final size of the output buffer is known before the contents are ready.
    *   During <a href="https://github.com/google/snappy/blob/master/snappy.cc#L1386">compression</a>, an upperbound on the final compressed size is known, allowing data to be efficiently added to the output buffer (eliding `append`'s checks) and the string to be shrunk to its final, correct size.

*   [[Protobuf]] avoids extraneous copies or initialization when the
    size is known before data is available (especially during parsing or
    serialization).

## MongoDB ## {#mongodb}

MongoDB has a string builder that could have been implemented in terms of
`basic_string` as a return value. However, as explained by Mathias Stearn, zero
initialization was measured and was too costly. Instead a custom string builder
type is used:

E.g.: <a
href="https://github.com/mongodb/mongo/blob/67da083face9dabdf95a5ffb72d3da675269b4c7/src/mongo/db/fts/unicode/string.h#L128-L143">
https://github.com/mongodb/mongo/blob/master/src/mongo/db/fts/unicode/string.h
</a>

<xmp>
/**
 * Strips diacritics and case-folds the utf8 input string, as needed to support
 * options.
 *
 * The options field specifies what operations to *skip*, so kCaseSensitive
 * means to skip case folding and kDiacriticSensitive means to skip diacritic
 * striping. If both flags are specified, the input utf8 StringData is returned
 * directly without any processing or copying.
 *
 * If processing is performed, the returned StringData will be placed in
 * buffer.  buffer's contents (if any) will be replaced. Since we may return
 * the input unmodified the returned StringData's lifetime is the shorter of
 * the input utf8 and the next modification to buffer. The input utf8 must not
 * point into buffer.
 */
static StringData caseFoldAndStripDiacritics(StackBufBuilder* buffer,
                                             StringData utf8,
                                             SubstrMatchOptions options,
                                             CaseFoldMode mode);
</xmp>
(Comments re-wrapped.)

## VMware ## {#vmware}

VMware has an internal string builder implementation that avoids `std::string`
due, in part, to `reserve`'s zero-writing behavior. This is similar in spirit to
the MongoDB example above.

## Discussion on std-proposals ## {#std}

This topic was discussed in 2013 on std-proposals in a thread titled "Add
basic_string::resize_uninitialized (or a similar mechanism)":</br> <a
href="https://groups.google.com/a/isocpp.org/forum/#!topic/std-proposals/XIO4KbBTxl0">
https://groups.google.com/a/isocpp.org/forum/#!topic/std-proposals/XIO4KbBTxl0</a>

## DynamicBuffer ## {#dynamicbuffer}

The [[N4734]] (the Networking TS) has *dynamic buffer* types.

## P1020R0 ## {#p1020}

See also [[P1020R0]] "Smart pointer creation functions for default
initialization".

## Boost ## {#boost}

Boost provides a related optimization for vector-like containers,
introduced in <a
href="https://github.com/boostorg/container/commit/14f092ab00def8e692b81d57d0466a617a6f6130">
[SVN r85964] </a> by Ion GaztaÃ±aga.

E.g.: <a
href="https://github.com/boostorg/container/blob/develop/include/boost/container/vector.hpp">
boost/container/vector.hpp</a>:

<xmp>
   //! <b>Effects</b>: Constructs a vector that will use a copy of allocator a
   //!   and inserts n default initialized values.
   //!
   //! <b>Throws</b>: If allocator_type's allocation
   //!   throws or T's default initialization throws.
   //!
   //! <b>Complexity</b>: Linear to n.
   //!
   //! <b>Note</b>: Non-standard extension
   vector(size_type n, default_init_t);
   vector(size_type n, default_init_t, const allocator_type &a)
   ...
   void resize(size_type new_size, default_init_t);
   ...
</xmp>

These optimizations are also supported in Boost Container's `small_vector`,
`static_vector`, `deque`, `stable_vector`, and `string`.

# Questions for LEWG # {#questions}

1.  Is LEWG satisified with this approach?

# History # {#history}

## R1 &rarr; R2 ## {#R2}

Applied feedback from [[SAN]] Meeting reviews.

*   Reverted design to "option A" proposed in [[P1072R0]]
*   Added discussion of alternatives considered

## R0 &rarr; R1 ## {#R1}

Applied feedback from LEWG [[post-Rapperswil]] Email Review:

*   Shifted to a new vocabulary types: `storage_buffer` / `storage_node`

    *   Added presentation of `storage_buffer` as a new container type
    *   Added presentation of `storage_node` as a node-like type

*   Added discussion of design and implementation considerations.

*   Most of [[P1010R1]] Was merged into this paper.

<pre class=biblio>
{
    "Abseil": {
        "href": "https://github.com/abseil/abseil-cpp",
        "date": "2018-09-22",
        "title": "Abseil"
    },
    "SAN": {
        "href": "http://wiki.edg.com/bin/view/Wg21sandiego2018/P1072",
	"date": "2018-11-07",
	"title": "San Diego Meeting Minutes"
    },
    "post-Rapperswil": {
        "href": "http://lists.isocpp.org/lib-ext/2018/08/8299.php",
        "date": "2018-08-26",
        "title": "LEWG Weekly - P1072"
    },
    "N4734": {
        "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4734.pdf",
        "date": "2018-04-04",
        "title": "Working Draft, C++ Extensions for Networking"
    },
    "N4762": {
        "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4762.pdf",
        "date": "2018-07-07",
        "title": "Working Draft, Standard for Programming Language C++"
    },
    "N4778": {
        "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4762.pdf",
        "date": "2018-07-07",
        "title": "Working Draft, Standard for Programming Language C++"
    },

    "P0083R3": {
        "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0083r3.pdf",
        "date": "2016-06-24",
        "title": "Splicing Maps and Sets"
    },
    "P0593R2": {
        "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0593r2.html",
        "date": "2018-02-11",
        "title": "Implicit creation of objects for low-level object manipulation"
    },
    "P1010R1": {
        "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1010r1.html",
        "date": "2018-10-08",
        "title": "Container support for implicit lifetime types."
    },
    "P1020R0": {
        "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1020r0.html",
        "date": "2018-04-08",
        "title": "Smart pointer creation with default initialization"
    },
    "P1020R1": {
	"href": "https://wg21.link/P1020R1",
	"date": "2018-11-06",
	"title": "Smart pointer creation with default initialization"
    },
    "P1072R0": {
        "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1072r0.html",
        "date": "2018-05-04",
        "title": "Default Initialization for basic_string"
    },
    "P1072R1": {
        "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1072r1.html",
        "date": "2018-10-07",
        "title": "Optimized Initialization for basic_string and vector"
    },
    "P1144R0": {
        "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1144r0.html",
        "date": "2018-10-04",
        "title": "Object relocation in terms of move plus destroy"
    },
    "Protobuf": {
        "href": "https://github.com/protocolbuffers/protobuf",
        "date": "2018-09-22",
        "title": "Protocol Buffers"
    },
    "Snappy": {
        "href": "https://github.com/google/snappy",
        "date": "2018-09-21",
        "title": "Snappy"
    }
}
</pre>
