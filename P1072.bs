<pre class='metadata'>
Title: basic_string::resize_default_init
Status: D
Shortname: P1072
Group: WG21
Revision: 5
Editor: Chris Kennelly, Google, ckennelly@google.com
Editor: Mark Zeren, VMware, mzeren@vmware.com
Date: 2019-07-17
Audience: LEWG
Audience: LWG
Audience: SG16
Abstract: Allow access to default-initialized elements of basic_string.
URL: http://wg21.link/D1072R5
Markup Shorthands: markdown yes
Default Highlight: C++
</pre>

# Motivation # {#mot}

Performance sensitive code is impacted by the cost of initializing and
manipulating strings. When streaming data into a `basic_string`, a
programmer is faced with an unhappy choice:

* **Pay for extra initialization** &mdash; `resize`, which zero
    initializes, followed by copy.

* **Pay for extra copies** &mdash; Populate a temporary buffer, copy
    it to the string.

* **Pay for extra "bookkeeping"** &mdash; `reserve` followed by small
    appends, each of which checks capacity and null terminates.

The effects of these unhappy choices can all be measured at scale, yet
C++'s hallmark is to leave no room between the language (or in this
case the library) and another language.

LEWGI polled on this at the [[SAN]] Meeting:

<blockquote>
We should promise more committee time to [[P1072R1]], knowing that our
time is scarce and this will leave less time for other work?
<br/>*Unanimous consent*
</blockquote>

LEWG at the [[SAN]] Meeting:

<blockquote>
We want to solve this problem
<table>
<tr><th>SF</th><th>F</th><th>N</th><th>A</th><th>SA</th></tr>
<tr><td>17</td><td>5</td><td>0</td><td>0</td><td>0</td></tr>
</table>

Willing to solve this for string without solving it for vector
<table>
<tr><th>SF</th><th>F</th><th>N</th><th>A</th><th>SA</th></tr>
<tr><td>6</td><td>9</td><td>2</td><td>1</td><td>0</td></tr>
</table>
</blockquote>

# Proposal # {#proposal}

This proposal addresses the problem by adding
`basic_string::resize_default_init`:

<blockquote>
<pre highlight="">
template&lt;typename Operation&gt;
void resize_default_init(size_type n, Operation op);
</pre>
<ol start="8">
<li>*Throws:* `out_of_range` if `op(data(), n) > n`.
<li>*Effects:* Alters the value of `*this` as follows:
     <ol>
     <li>— If `n <= size()`, erases the last `size() - n` elements.</li>
     <li>— If `n > size()`, appends `n - size()` default-initialized
         elements.</li>
     </ol>
     Invokes `erase(op(data(), n))`.
</li>
<li>*Remarks:* Let `m = op(data(), n)`.  `op` shall replace
    ([**expr.ass**]) values in the range `[data(), data()+m)`.
</li>
</ol>
</blockquote>

In order to enable `resize_default_init`, this proposal makes it
implementation-defined whether `basic_string` uses
`allocator_traits::construct` and `allocator_traits::destroy` to
construct and destroy the "char-like objects" that it controls. See
[[#allocator]] and [[#wording]] below for more details.

# Implementation # {#impl}

`libc++` includes a private implementation of a prior version of this
proposal (based on an earlier revision) and uses it to avoid a dynamic
allocation in `std::filesystem` [[LIBC++]].

# Examples # {#examples}

## Stamping a Pattern ## {#pattern}

Consider writing a pattern several times into a string:
<xmp>
std::string GeneratePattern(const std::string& pattern, size_t count) {
   std::string ret;

   ret.reserve(pattern.size() * count);
   for (size_t i = 0; i < count; i++) {
     // SUB-OPTIMAL:
     // * Writes 'count' nulls
     // * Updates size and checks for potential resize 'count' times
     ret.append(pattern);
   }

   return ret;
}
</xmp>

Alternatively, we could adjust the output string’s size to its final size,
avoiding the bookkeeping in `append` at the cost of extra initialization:
<xmp>
std::string GeneratePattern(const std::string& pattern, size_t count) {
   std::string ret;

   const auto step = pattern.size();
   // SUB-OPTIMAL: We memset step*count bytes only to overwrite them.
   ret.resize(step * count);
   for (size_t i = 0; i < count; i++) {
     // GOOD: No bookkeeping
     memcpy(ret.data() + i * step, pattern.data(), step);
   }

   return ret;
}
</xmp>

With this proposal:

<xmp>
std::string GeneratePattern(const std::string& pattern, size_t count) {
   std::string ret;

   const auto step = pattern.size();
   // GOOD: No initialization
   ret.resize_default_init(step * count, [&](char* buf, size_t n) {
       for (size_t i = 0; i < count; i++) {
         // GOOD: No bookkeeping
         memcpy(buf + i * step, pattern.data(), step);
       }
       return step * count;
   });

   return ret;
}
</xmp>

## Interacting with C ## {#c}

Consider wrapping a C API while working in terms of C++'s `basic_string`
vocabulary.  We *anticipate* over-allocating, as computation of the *length* of
the data is done simultaneously with the computation of the *contents*.

<xmp>
extern "C" {
  int compress(void* out, size_t* out_size, const void* in, size_t in_size);
  size_t compressBound(size_t bound);
}

std::string CompressWrapper(std::string_view input) {
    std::string compressed;
    // Compute upper limit of compressed input.
    size_t size = compressBound(input.size());

    // SUB-OPTIMAL: Extra initialization
    compressed.resize(size);
    int ret = compress(&*compressed.begin(), &size, input.data(), input.size());
    if (ret != OK) {
      throw ...some error...
    }

    // Set actual size.
    compressed.erase(size);
    return compressed;
}
</xmp>

With this proposal:

<xmp>
extern "C" {
  int compress(void* out, size_t* out_size, const void* in, size_t in_size);
  size_t compressBound(size_t bound);
}

std::string CompressWrapper(std::string_view input) {
    std::string compressed;
    // Compute upper limit of compressed input.
    size_t size = compressBound(input.size());

    // GOOD: No initialization
    compressed.resize_default_init(size, [&](char* buf, size_t n) {
        int ret = compress(buf, &size, input.data(), input.size());
        if (ret != OK) {
          throw ...some error...
        }
        return n;
    }
    return compressed;
}
</xmp>

# Design Considerations # {#design}

## Method vs. Alternatives

`resize_default_init` exposes users to UB if they read indeterminate
([**basic.indet**] (6.6.4)) values in the string buffer passed to `op`. Despite
this foot-gun, `resize_default_init` is appealing because:

* Uninitialized buffers are not uncommon in C++. See for example `new
  T[20]` or the recently adopted `make_unique_default_init`.

* Dynamic analyzers like Memory Sanitizer [[MSan]] and Valgrind
  [[Valgrind]] can catch uninitialized reads.

During the [[SAN]] Meeting LEWG expressed a preference for
implementing this functionality as a new method on `basic_string` (as
proposed in [[P1072R0]]) rather than a standalone "storage buffer"
type (one option in [[P1072R1]]):

<blockquote>
Method on string vs storage_buffer type:
<table>
<tr><th>Strong Method</th><th>Method</th><th>Neutral</th><th>Type</th><th>Strong Type</th></tr>
<td>9</td><td>2</td><td>3</td><td>2</td><td>2</td></tr>
</table>
</blockquote>

During the [[KOA]] Meeting, LEWG expressed a preference for not weakening
`basic_string`'s invariants after `resize_default_init` returns.  Under this
revision:

*  A default-initialized buffer is *only* accessible to `op`.
*  Under penalty of undefined behavior, `op` must assign (replace) the
   values in resulting buffer. The default initialized portion
   (`[data()+m, data()+n)`) above is erased and inaccessible to the
   program without further violation of class invariants.
*  This proposal follows the "lambda" option discussed in [[SAN]].

Several other alternatives were discussed at [[SAN]], [[KOA]], and on the
reflector.  Please see [[#alternatives]] below for more details.

## Allocator Interaction ## {#allocator}

Unlocking the desired optimizations requires *some* change to
`basic_string`'s interaction with allocators. This proposal does what
we think is the simplest possible change: remove the requirement that
`basic_string` call `allocator_traits::construct` or
`allocator_traits::destroy`.

This restriction should be acceptable because `basic_string` is
defined to only hold "non-array trivial standard-layout" types.
[**strings.general**] p1:

<blockquote>

This Clause describes components for manipulating sequences of any
non-array trivial standard-layout (6.7) type. Such types are called
*char-like types*, and objects of *char-like types* are *called
char-like objects* or simply *characters*.

</blockquote>

Removing calls to `construct` and `destroy` is compatible with
`pmr::basic_string` as long as `uses_allocator_v<charT>` is `false`,
which should be the case in practice.

Along the way, this proposal clarifies ambiguous language in
[**string.require**] and [**container.requirements.general**] by:

* Stating explicitly that `basic_string` is allocator-aware.

* Introducing the term "allocator-aware" earlier in
  [**container.requirements.general**].

* Not attempting to mention other "components" in
  [**container.requirements.general**]. The other allocator-aware
  containers (just `basic_string` and `regex::match_results`?) can
  independently state that they are "allocator-aware" in their own
  clauses.

libstdc++ and msvc allow strings of non-trivial type. That might force
those libraries to continue to support `construct` and `destroy` as
"extensions". On the other hand, libc++ disallows non-trivial
`charT`s, so any such extensions are non-portable. See [godbolt.org](
https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAKxAEZSAbAQwDtRkBSAJgCFufSAZ1QBXYskwgA5NwDMeFsgYisAag6yAwoILEFwDdg4AGAIInTO9CBAAjJoLzIA%2Bjr1sN2gtZBv9h1QAzVFQIAEp1AHY%2BM1U41Ssbe0cXPw8tRN9df1lsBI0Y03iEgDpiTEcAL0wILjCCi2LygjEWfNlCjkiAEQspMMZpAFYpUhZpY1HUaU1%2BfgTRcUx1LllaUYIJ/oGAaxBVksiATgAOABYzgDYuE64rs9pLy8GpM9HxqUnSaalRwRBjKRNp9%2BqQ4LAYIgUKgALYABzwDEwZAoEDQ8MRyJQzDYzl0IhYO1IgURBGR/wgti2pFsCiYxAAntJ1qR0TDMCwCAB5FgMJkg0hYGGsYBI6n4crIAh4ABuFWpmAAHphkCIyczRgoyQwNUC9DCtgMcew5rxGHhbP9IANUHDpagWP8pABaKwMC0abru2ycXj8P6LCR0I3Dd7Un6Kk6XZ2XM6qJQi1QQfGEiIQXCEEgrNakVSaWEIpHEbO0CKzP28DaG3YgIZHEpHSKRO60c6RIa0SLGWRDF5vUgGoaAj5fH5/AFAw1gyEQJCiAhwtXkSjowtY%2BiYfBEYh0UgAd2ITDhGpDUhGY3D0jktFUe8ICFUkejsfjxqTKZ2YSrILCAwQmCYLAd3CPtRkHYdL1%2BIQJ2BSZf1IPYDi4Otbi4LgjlkM4hlkI4zheWQwwFMdJx/ad4HBKFV0xFEVwLaiQGAQQWCPQQEFQAhiVJclKCpAVaWYxldTZDluV5fkviFEUxQFCUVWlOUnS%2BJUVTVSQpBZLVMB1dSNn1KdjRQU0BG9K0QNte1HWkAMxCDUsXnPEcpmkJ8YzjYBkGQd9iAJT8kwzbcS1zfMMSLbM6jzIzvzgv8AKAygazuEoTlodDaDS44TiOdCuFAgdawgoirOgwFYNBCjZxAedFw41EqKLfZSE3TMd3oA8jxPezCNHK9Vi4W970fKNXNUdzPOTbzUyi7ZSH/QCsRA7T%2B3Ai9Cqg/4SurBD9iGEorijG5uzOSIjtjfCuqcqDSoGcqZyQOrkWXNE6PqqQZWQOE4WcGVaCOZxaCGZwIBlQQ/oBk4wmcRVY1GEkGDJYgKV4r5%2BPpfkWWEzkeT5cVMGFNhpIkvBJXk%2BUBWU1V1R08hOS03VsgNUiDN9PgzRM%2BAbTtPAHSdaylmDTqVu6qQobjGFBDe1Rvvrf6kwANQAZVUf6krTfys2vILnuRbNZDLSKSOimbYvmmtaDOEocJOYxjCGS5ZG7S4TiGVZcuWxzviK9aDbK27KrVarHvundZEarcSF3Nrjx008HMguRZH6ggHxF1QxYlqWShliAFaVnbwam%2BDZrihbpCW/LBYu8cNp/BLIl2yI1m7WRMtkTDkOebSCIrj3Ls27SuHOnuC4GOUEa58YziAA%3D%3D%3D).

## Bikeshedding ## {#bikeshed}

What do we want to call this method?

* `resize_default_init` (as proposed). This is consistent with
  `make_unique_default_init` [[P1020R1]], adopted in San Diego. Also,
  specifying default-initialization throws a bone to libraries that
  have historically allowed non-trivial `charT` types in
  `basic_string`.

* `resize_uninitialized` (as proposed in R0). "Uninitialized" is
  different from "default-initialized", which is what we want to
  specify. Also, `uninitialized` is already used elsewhere in the
  Library to mean "not constructed at all", as in
  `uninitialized_copy`; so this would be an overloading of the term.

# Alternatives Considered # {#alternatives}

## Tag Type ## {#tag}

At the [[SAN]] Meeting, LEWG showed support for a tag argument type:

<blockquote>
Approval (vote for as many as you find acceptable)
<table>
<tr><td>13 </td><td>**Go back to resize_uninitialized**</td></tr>
<tr><td>15 </td><td>**Do tag type (default_initialize) for c'tor / resize()**</td></tr>
<tr><td>12 </td><td>**Continue with storage_buffer (as per R2 of this paper)**</td></tr>
<tr><td> 7 </td><td>**Crack open with a lambda**</td></tr>
<tr><td> 7 </td><td>**RAII separate type**</td></tr>
</table>
</blockquote>

For example:
<xmp>
std::string GeneratePattern(const std::string& pattern, size_t count) {
   const auto step = pattern.size();

   // GOOD:  No initialization
   std::string ret(step * count, std::string::default_init);
   for (size_t i = 0; i < count; i++) {
     // GOOD: No bookkeeping
     memcpy(ret.data() + i * step, pattern.data(), step);
   }

   return ret;
}
</xmp>

Benefits:

* A constructor that takes a tag type simplifies some use cases, like
  the example above.

* Matches existing practice in Boost. See [[#boost]].

Drawbacks:

* Feature creep / complexity — A tag type invites generalizing for all
  allocator-aware container types. We agree that this is desirable and
  even has implementation experience in Boost. However default
  initialization is not enough. There is also "implicit construction"
  (see [[P1010R1]], [[P0593R2]]) and "relocation" (see [[P1144R0]],
  [[P1029R1]]). Neither of these features are yet in the language. It
  is too early to generalize. Note that the second poll quoted in
  [[#mot]] shows support for solving this problem for `[basic_]string`
  but not `vector`.

* In reflector discussion of `make_unique_default_init` [[Zero]],
  there was a preference for avoiding tag types. The standard library
  has `copy_backward`, not `copy` with a tag, and `count_if`, rather
  than `count` with a predicate.

Conclusion:

LEWG should explore tags for allocator-aware containers, but that work
should not block near-term enablement of efficient [std::]string
builders.

## Non-Lambda Approach ## {#nonlambda}

In [[P1072R0]] and [[P1072R3]] of this proposal, the authors considered a
method `resize_default_init` / `resize_uninitialized` which left a
default-initialized buffer accessible to users of the `basic_string` instance
after the method returned.  This method was rejected in [[KOA]], due to the
weakened class invariants.

For illustration:

<xmp>
extern "C" {
  int compress(void* out, size_t* out_size, const void* in, size_t in_size);
  size_t compressBound(size_t bound);
}

std::string CompressWrapper(std::string_view input) {
    std::string compressed;
    // Compute upper limit of compressed input.
    size_t size = compressBound(input.size());

    // GOOD: No initialization
    compressed.resize_default_init(size);
    int ret = compress(&*compressed.begin(), &size, input.data(), input.size());
    if (ret != OK) {
      throw ...some error...
    }

    // Suppose size is the value of size before the call to compress and size'
    // is the value of size after the call to compress.
    //
    // If size' < size, then:
    //   std::cout << compressed[size' + 1]
    // ...triggers a read of uninitialized data.

    // Set actual size.
    compressed.erase(size);
    return compressed;
}
</xmp>



## Standalone Type:  `storage_buffer` ## {#buffer}

In [[P1072R1]], we considered `storage_buffer`, a standalone type
providing a `prepare` method (similar to the `resize_uninitialized` method
proposed here) and `commit` (to promise, under penalty of UB, that the
buffer had been initialized).

At the [[SAN]] Meeting, this approach received support from LEWGI in light of
the [[post-Rapperswil]] email review indicating support for a distinct type.
This approach was rejected by the larger LEWG room in San Diego Meeting Diego.

The proposed type would be move-only.

<xmp>
std::string GeneratePattern(const std::string& pattern, size_t count) {
   std::storage_buffer<char> tmp;

   const auto step = pattern.size();
   // GOOD:  No initialization
   tmp.prepare(step * count + 1);
   for (size_t i = 0; i < count; i++) {
     // GOOD: No bookkeeping
     memcpy(tmp.data() + i * step, pattern.data(), step);
   }

   tmp.commit(step * count);
   return std::string(std::move(tmp));
}
</xmp>

For purposes of the container API, `size()` corresponds to the *committed*
portion of the buffer.  This leads to more consistency when working with (and
explicitly copying to) other containers via iterators, for example:

<xmp>
    std::storage_buffer<char> buf;
    buf.prepare(100);
    *fill in data*
    buf.commit(50);

    std::string a(buf.begin(), buf.end());
    std::string b(std::move(buf));

    assert(a == b);
</xmp>

Benefits:
*   By being move-only, we would not have the risk of copying types with
    trap representations (thereby triggering UB).
*   Uninitialized data is only accessible from the `storage_buffer` type.
    For an API working with `basic_string`, no invariants are weakened.
    Crossing an API boundary with a `storage_buffer` is much more obvious than
    a "`basic_string` with possibly uninitialized data."  Uninitialized bytes
    (the promise made by `commit`) never escape into the valid range of
    `basic_string`.

Drawbacks:
*   `storage_buffer` requires introducing an extra type to the standard
    library, even though its novel functionality (from `string` and
    `vector`) is limited to the initialization abilities.
*   `basic_string` is often implemented with a short-string optimization (SSO) and an extra type would need to implement that (likely by additional checks when moving to/from the `storage_buffer`) that are often unneeded.

## Externally-Allocated Buffer Injection ## {#external}

In [[P1072R1]], we considered that `basic_string` could "adopt" an
externally `allocator::allocate`'d buffer. At the [[SAN]] Meeting, we
concluded that this was:

*  **Not critical**
*  **Not constrained in the future**
*  **Overly constraining to implementers**.  Allowing users to provide their own buffers runs into the "offset problem".  Consider an implementation that stores its `size` and `capacity` inline with its data, so `sizeof(container) == sizeof(void*)`.

    <xmp>
    class container {
      struct Rep {
        size_t size;
        size_t capacity;
      };

      Rep* rep_;
    };
    </xmp>

    If using a `Rep`-style implementation, the mismatch in offsets
    requires an O(N) move to shift the contents into place and trigger a
    possible reallocation.

*  **Introducing new pitfalls**.  It would be easy to mix `new[]` and `allocator::allocate` inadvertently.

# Related Work # {#related}

## Google ## {#google}

Google has a local extension to `basic_string` called `resize_uninitialized`
which is wrapped as `STLStringResizeUninitialized`.

*   [[Abseil]] uses this to avoid bookkeeping overheads in `StrAppend` and
    `StrCat`.
*   [[Snappy]]

    *   In <a href="https://github.com/google/snappy/blob/master/snappy.cc#L1318">decompression</a>, the final size of the output buffer is known before the contents are ready.
    *   During <a href="https://github.com/google/snappy/blob/master/snappy.cc#L1386">compression</a>, an upperbound on the final compressed size is known, allowing data to be efficiently added to the output buffer (eliding `append`'s checks) and the string to be shrunk to its final, correct size.

*   [[Protobuf]] avoids extraneous copies or initialization when the
    size is known before data is available (especially during parsing or
    serialization).

## MongoDB ## {#mongodb}

MongoDB has a string builder that could have been implemented in terms of
`basic_string` as a return value. However, as explained by Mathias Stearn, zero
initialization was measured and was too costly. Instead a custom string builder
type is used:

E.g.: <a
href="https://github.com/mongodb/mongo/blob/67da083face9dabdf95a5ffb72d3da675269b4c7/src/mongo/db/fts/unicode/string.h#L128-L143">
https://github.com/mongodb/mongo/blob/master/src/mongo/db/fts/unicode/string.h
</a>

<xmp>
/**
 * Strips diacritics and case-folds the utf8 input string, as needed to support
 * options.
 *
 * The options field specifies what operations to *skip*, so kCaseSensitive
 * means to skip case folding and kDiacriticSensitive means to skip diacritic
 * striping. If both flags are specified, the input utf8 StringData is returned
 * directly without any processing or copying.
 *
 * If processing is performed, the returned StringData will be placed in
 * buffer.  buffer's contents (if any) will be replaced. Since we may return
 * the input unmodified the returned StringData's lifetime is the shorter of
 * the input utf8 and the next modification to buffer. The input utf8 must not
 * point into buffer.
 */
static StringData caseFoldAndStripDiacritics(StackBufBuilder* buffer,
                                             StringData utf8,
                                             SubstrMatchOptions options,
                                             CaseFoldMode mode);
</xmp>
(Comments re-wrapped.)

## VMware ## {#vmware}

VMware has an internal string builder implementation that avoids `std::string`
due, in part, to `reserve`'s zero-writing behavior. This is similar in spirit to
the MongoDB example above.

## Discussion on std-proposals ## {#std-proposals}

This topic was discussed in 2013 on std-proposals in a thread titled "Add
basic_string::resize_uninitialized (or a similar mechanism)":</br> <a
href="https://groups.google.com/a/isocpp.org/forum/#!topic/std-proposals/XIO4KbBTxl0">
https://groups.google.com/a/isocpp.org/forum/#!topic/std-proposals/XIO4KbBTxl0</a>

## DynamicBuffer ## {#dynamicbuffer}

The [[N4734]] (the Networking TS) has *dynamic buffer* types.

## P1020R1 ## {#p1021}

See also [[P1020R1]] "Smart pointer creation functions for default
initialization". Adopted in San Diego.

## Boost ## {#boost}

Boost provides a related optimization for vector-like containers,
introduced in <a
href="https://github.com/boostorg/container/commit/14f092ab00def8e692b81d57d0466a617a6f6130">
[SVN r85964] </a> by Ion Gaztañaga.

E.g.: <a
href="https://github.com/boostorg/container/blob/develop/include/boost/container/vector.hpp">
boost/container/vector.hpp</a>:

<xmp>
   //! <b>Effects</b>: Constructs a vector that will use a copy of allocator a
   //!   and inserts n default initialized values.
   //!
   //! <b>Throws</b>: If allocator_type's allocation
   //!   throws or T's default initialization throws.
   //!
   //! <b>Complexity</b>: Linear to n.
   //!
   //! <b>Note</b>: Non-standard extension
   vector(size_type n, default_init_t);
   vector(size_type n, default_init_t, const allocator_type &a)
   ...
   void resize(size_type new_size, default_init_t);
   ...
</xmp>

These optimizations are also supported in Boost Container's `small_vector`,
`static_vector`, `deque`, `stable_vector`, and `string`.

## Thrust ## {#thrust}

The Thrust library has "a RAII-type `thrust::detail::temporary_array`
which has a vector-like interface and a constructor with a tag
parameter that indicates its elements should not be initialized." -
[Bryce Adelstein Lelbach].


E.g. <a
href="https://github.com/thrust/thrust/blob/417d78471dadefa3087ff274e64f43ce74acfd3d/thrust/detail/temporary_array.inl#L47">thrust/thrust/detail/temporary_array.inl</a>:

<xmp>
template<typename T, typename TemporaryArray, typename Size>
__host__ __device__
typename thrust::detail::disable_if<
  avoid_initialization<T>::value
>::type
  construct_values(TemporaryArray &a,
                   Size n)
{
  a.default_construct_n(a.begin(), n);
} // end construct_values()
</xmp>

# Wording # {#wording}

Wording is relative to [[N4791]].

Motivation for some of these edits can be found in [[#allocator]].

## [<strong>basic.string</strong>] ## {#basic.string}

In [**basic.string**] [20.3.2], in the synopsis, add
`resize_default_init`:

<blockquote>
<pre highlight="">
...
    // <em>20.3.2.4</em>, capacity
    size_type size() const noexcept;
    size_type length() const noexcept;
    size_type max_size() const noexcept;
    void resize(size_type n, charT c);
    void resize(size_type n);
    <ins>template&lt;typename Operation&gt;</ins>
    <ins>void resize_default_init(size_type n, Operation op);</ins>
    size_type capacity() const noexcept;
    void reserve(size_type res_arg);
    void shrink_to_fit();
    void clear() noexcept;
    [[nodiscard]] bool empty() const noexcept;
</pre>
</blockquote>

In [**string.require**] [20.3.2.1] clarify that `basic_string` is an
allocator-aware container, and then add an exception for `construct`
and `destroy`.

<blockquote>

3. In every specialization `basic_string<charT, traits, Allocator>`,
  the type `allocator_traits<Allocator>::value_type` shall name the
  same type as `charT` <del>. Every object of type
  `basic_string<charT, traits, Allocator>` uses an object of type
  `Allocator` to allocate and free storage for the contained `charT`
  objects as needed. The Allocator object used is obtained as
  described in [container.requirements.general]. In every
  specialization `basic_string<charT, traits, Allocator>`</del>, <ins>
  and</ins> the type `traits` shall satisfy the character traits
  requirements ([char.traits]). [*Note:* The program is ill-formed if
  `traits::char_type` is not the same type as `charT`. &mdash; *end
  note*]

4. <ins> `basic_string` is an allocator-aware container as described
  in [container.requirements.general], except that it is
  implementation-defined whether `allocator_traits::construct` and
  `allocator_traits::destroy` are used to construct and destroy the
  contained `charT` objects. </ins>

5. References, pointers, and iterators referring to the elements of a
  `basic_string` sequence may be invalidated by the following uses of
  that `basic_string` object:<br/>...

</blockquote>

In [**string.capacity**] [20.3.2.4]:

<blockquote>
<pre highlight="">
void resize(size_type n, charT c);
</pre>

<ol start="6">

<li>*Effects:* Alters the value of `*this` as follows:
     <ol>
     <li>— If `n <= size()`, erases the last `size() - n` elements.</li>
     <li>— If `n > size()`, appends `n - size()` copies of `c`.</li>
     </ol>
</li>
</ol>

<pre highlight="">
void resize(size_type n);
</pre>
<ol start="7">
<li>*Effects:* Equivalent to `resize(n, charT())`.</li>
</ol>

<pre highlight=""><ins>
template&lt;typename Operation&gt;
void resize_default_init(size_type n, Operation op);
</ins></pre>

<ol start="8">

<li><ins>*Effects:*  Let `o = size()`.  Alters the value of `*this` as follows:</ins>
     <ol>
     <li><ins>— If `n <= size()`, erases the last `size() - n`
     elements.</ins></li>
     <li><ins>— If `n > size()`, appends `n - size()`
         default-initialized elements.</ins></li>
     </ol>
     <ins>Invokes `erase(op(data(), n))`.</ins>
</li>
<li><ins>*Remarks:* Let `m = op(data(), n)`. `op` shall replace
    ([**expr.ass**]) the values stored in the character array
    `[data()+o, data()+m)`.</ins></li>
</ol>

<pre highlight="">
size_type capacity() const noexcept;
</pre>
...
</blockquote>

## [<strong>container.requirements.general</strong>] ## {#container}

In [**container.requirements.general**] [21.2.1] clarify the ambiguous
"components affected by this subclause" terminology in p3. Just say
"allocator-aware containers".

<blockquote>
<ol start="3">

<li><ins>All of the containers defined in this Clause except `array`
    are allocator-aware containers.</ins> <del> For the components
    affected by this subclause that declare an allocator_type</del>
    <ins>Objects</ins><del>objects</del> stored in <del> these components
    </del> <ins> allocator-aware containers, unless otherwise specified, </ins>
    shall be constructed using the function
    `allocator_traits<allocator_type>::rebind_traits<U>::construct` and
    destroyed using the function
    `allocator_traits<allocator_type>::rebind_traits<U>::destroy` (19.10.9.2).
    </li>

</ol>
</blockquote>

We can then simplify p15:
<blockquote>
<ol start="15">

<li><del>All of the containers defined in this Clause and in 20.3.2
    except `array` meet the additional requirements of an
    allocator-aware container, as</del> <ins> Allocator-aware
    containers meet the additional requirements described in Table
    67.</ins></li>

</ol>
</blockquote>


# Questions for LEWG # {#questions}

1.  Is LEWG satisfied with this approach?

# History # {#history}

## R4 &rarr; R5 ## {#R4}

A draft of this revision was presented to LEWG at the [[Cologne]] meeting.

<blockquote>
Forward to LWG for C++23
<table>
<tr><th>SF</th><th>F</th><th>N</th><th>A</th><th>SA</th></tr>
<tr><td>10</td><td>5</td><td>1</td><td>0</td><td>0</td></tr>
</table>
</blockquote>

## R3 &rarr; R4 ## {#R3}

*   Applied feedback from the [[KOA]] meeting.
*   Moved to using a callback routine, rather than leaving invariants
    weakened from the time `resize_default_init` returned until values
    in the buffer were assigned.

## R2 &rarr; R3 ## {#R2}

*   Applied Jonathan Wakely's editorial comments on [[#wording]].
*   Rebased on [[N4791]].
*   Editorial changes to [[#mot]] and [[#tag]] to support our design
    choice.
*   Added the reference to [[LIBC++]] in [[#impl]].

## R1 &rarr; R2 ## {#R2}

Applied feedback from [[SAN]] Meeting reviews.

*   Reverted design to "option A" proposed in [[P1072R0]].
*   Switched from `resize_uninitialized` to `resize_default_init`.
*   Added discussion of alternatives considered.
*   Specified allocator interaction.
*   Added wording.

## R0 &rarr; R1 ## {#R1}

Applied feedback from LEWG [[post-Rapperswil]] Email Review:

*   Shifted to a new vocabulary types: `storage_buffer` / `storage_node`

    *   Added presentation of `storage_buffer` as a new container type
    *   Added presentation of `storage_node` as a node-like type

*   Added discussion of design and implementation considerations.

*   Most of [[P1010R1]] Was merged into this paper.

# Acknowledgments # {#acknowledgments}

Thanks go to **Arthur O'Dwyer** for help with wording and proof
reading, to **Jonathan Wakely** for hunting down the language that
makes `basic_string` allocator-aware, and to **Glen Fernandes**,
**Corentin Jabot**, **Billy O'Neal**, and **Mathias Stearn** for
design discussion. Special thanks to **Eric Fiselier** for providing
the implmentation.


<pre class=biblio>
{
    "Abseil": {
        "href": "https://github.com/abseil/abseil-cpp",
        "date": "2018-09-22",
        "title": "Abseil"
    },
    "Cologne": {
        "href": "http://wiki.edg.com/bin/view/Wg21cologne2019/P1072",
        "date": "2019-07-19"
    },
    "KOA": {
        "href": "http://wiki.edg.com/bin/view/Wg21kona2019/P1072",
        "date": "2019-02-19",
        "title": "Kona Meeting Minutes"
    },
    "SAN": {
        "href": "http://wiki.edg.com/bin/view/Wg21sandiego2018/P1072",
	"date": "2018-11-07",
	"title": "San Diego Meeting Minutes"
    },
    "post-Rapperswil": {
        "href": "http://lists.isocpp.org/lib-ext/2018/08/8299.php",
        "date": "2018-08-26",
        "title": "LEWG Weekly - P1072"
    },
    "Zero": {
        "href": "http://lists.isocpp.org/lib-ext/2018/04/6712.php",
        "date": "2018-04-13",
        "title": "Listening to our customers: Zero-initialization issue"
    },
    "Protobuf": {
        "href": "https://github.com/protocolbuffers/protobuf",
        "date": "2018-09-22",
        "title": "Protocol Buffers"
    },
    "Snappy": {
        "href": "https://github.com/google/snappy",
        "date": "2018-09-21",
        "title": "Snappy"
    },
    "MSan": {
        "href": "https://clang.llvm.org/docs/MemorySanitizer.html",
        "title": "Memory Sanitizer"
    },
    "Valgrind": {
        "href": "http://www.valgrind.org",
        "title": "Valgrind"
    },
    "LIBC++": {
        "href": "http://llvm.org/viewvc/llvm-project?view=revision&revision=347589",
        "date": "2018-11-26",
        "title": "Add basic_string::__resize_default_init (from P1072)"
    }
}
</pre>
