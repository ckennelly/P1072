<pre class='metadata'>
Title: basic_string::resize_default_init
Status: P
Shortname: P1072
Group: WG21
Revision: 2
Editor: Chris Kennelly, Google, ckennelly@google.com
Editor: Mark Zeren, VMware, mzeren@vmware.com
Date: 2018-11-08
Audience: LEWG
Audience: LWG
Audience: SG16
Abstract: Allow access to default initialized elements of basic_string.
URL: http://wg21.link/P1072R2
Markup Shorthands: markdown yes
Default Highlight: C++
</pre>

# Motivation # {#mot}

Performance sensitive code is impacted by the cost of initializing and
manipulating strings: When streaming data into a `basic_string`, a
programmer is forced with an unhappy choice:

* **Pay for extra initialization** &mdash; `resize`, which zero
    initializes, followed by copy.

* **Pay for extra copies** &mdash; Populate a temporary buffer, copy
    it to the string.

* **Pay for extra "bookkeeping"** &mdash; `reserve` followed by small
    appends, each of which checks capacity and null terminates.

The effects of these unhappy choices can all be measured at scale.
C++'s hallmark is to leave no room between the language (or in this
case the library) and another language.

LEWGI polled on this at the [[SAN]] Meeting:

<blockquote>
We should promise more commitee time to [[P1072R1]], knowing that our
time is scarce and this will leave less time for other work?
<br/>*Unanimous consent*
</blockquote>

LEWG at the [[SAN]] Meeting:

<blockquote>
We want to solve this problem
<table>
<tr><th>SF</th><th>F</th><th>N</th><th>A</th><th>SA</th></tr>
<tr><td>17</td><td>5</td><td>0</td><td>0</td><td>0</td></tr>
</table>
</blockquote>

This proposal addresses the problem by adding
`basic_string::resize_default_init`.

## Example: Stamping a Pattern ## {#pattern}

Consider writing a pattern several times into a string:
<xmp>
std::string GeneratePattern(const std::string& pattern, size_t count) {
   std::string ret;

   ret.reserve(pattern.size() * count);
   for (size_t i = 0; i < count; i++) {
     // SUB-OPTIMAL:
     // * Writes 'count' nulls
     // * Updates size and checks for potential resize 'count' times
     ret.append(pattern);
   }

   return ret;
}
</xmp>

Alternatively, we could adjust the output string’s size to its final size,
avoiding the bookkeeping in `append` at the cost of extra initialization:
<xmp>
std::string GeneratePattern(const std::string& pattern, size_t count) {
   std::string ret;

   const auto step = pattern.size();
   // SUB-OPTIMAL: We memset step*count bytes only to overwrite them.
   ret.resize(step * count);
   for (size_t i = 0; i < count; i++) {
     // GOOD: No bookkeeping
     memcpy(ret.data() + i * step, pattern.data(), step);
   }

   return ret;
}
</xmp>

With this proposal:

<xmp>
std::string GeneratePattern(const std::string& pattern, size_t count) {
   std::string ret;

   const auto step = pattern.size();
   // GOOD:  No initialization
   ret.resize_default_init(step * count);
   for (size_t i = 0; i < count; i++) {
     // GOOD: No bookkeeping
     memcpy(ret.data() + i * step, pattern.data(), step);
   }

   return ret;
}
</xmp>

## Example: Interacting with C ## {#c}

Consider wrapping a C API while working in terms of C++'s `basic_string`
vocabulary.  We *anticipate* overallocating, as computation of the *length* of
the data is done simultaneously with the computation of the *contents*.

<xmp>
extern "C" {
  int compress(void* out, size_t* out_size, const void* in, size_t in_size);
  size_t compressBound(size_t bound);
}

std::string CompressWrapper(std::string_view input) {
    std::string compressed;
    // Compute upper limit of compressed input.
    size_t size = compressBound(input.size());

    // SUB-OPTIMAL:  Extra initialization
    compressed.resize(size);
    int ret = compress(compressed.begin(), &size, input.data(), input.size());
    if (ret != OK) {
      throw ...some error...
    }

    // Shrink compress to its true size.
    compress.resize(size);
    return compressed;
}
</xmp>

With this proposal:

<xmp>
extern "C" {
  int compress(void* out, size_t* out_size, const void* in, size_t in_size);
  size_t compressBound(size_t bound);
}

std::string CompressWrapper(std::string_view input) {
    std::string compressed;
    // Compute upper limit of compressed input.
    size_t size = compressBound(input.size());

    // GOOD:  No initialization
    compressed.resize_default_init(size);
    int ret = compress(compressed.begin(), &size, input.data(), input.size());
    if (ret != OK) {
      throw ...some error...
    }

    // Shrink compress to its true size.
    compress.commit(size);
    return std::string(std::move(compressed));
}
</xmp>

# Proposal # {#prop}

Wording relative to [[N4778]]

## [<strong>basic.string</strong>] ## {#basic.string}

In [**basic.string**] [20.3.2], in the synopsis, add
`resize_default_init`:

<blockquote>
<pre highlight="">
...
    // <em>23.3.2.4</em>, capacity
    size_type size() const noexcept;
    size_type length() const noexcept;
    size_type max_size() const noexcept;
    void resize(size_type n, charT c);
    void resize(size_type n);
    <ins>void resize_default_init(size_type n);</ins>
    size_type capacity() const noexcept;
    void reserve(size_type res_arg);
    void shrink_to_fit();
    void clear() noexcept;
    [[nodiscard]] bool empty() const noexcept;
</pre>
</blockquote>

In [**string.require**] [20.3.2.1] clarify that `basic_string` is an
allocator-aware container, and then add an exception for `construct`
and `destroy`.

<blockquote>

3. In every specialization `basic_string<charT, traits, Allocator>`,
  the type `allocator_traits<Allocator>::value_type` shall name the
  same type as `charT` <del>. Every object of type
  `basic_string<charT, traits, Allocator>` shall use an object of type
  `Allocator` to allocate and free storage for the contained `charT`
  objects as needed. The Allocator object used shall be obtained as
  described in [container.requirements.general]. In every
  specialization `basic_string<charT, traits, Allocator>`</del>, <ins>
  and</ins> the type `traits` shall satisfy the character traits
  requirements ([char.traits]), and the type `traits::char_type` shall
  name the same type as `charT`.

<ins>

4. `basic_string` is an allocator-aware container as described in
  [container.requirements.general], except that `basic_string`
  directly constructs and destroys elements of the sequence and does
  not call `allocator_traits::construct` or
  `allocator_traits::destroy`.

</ins>

5. References, pointers, and iterators referring to the elements of a
  `basic_string` sequence may be invalidated by the following uses of
  that `basic_string` object:<br/>...

</blockquote>

In [**basic.string.capacity**] [20.3.2.4]:

<blockquote>
<pre highlight="">
void resize(size_type n, charT c);
</pre>

<ol start="6">

<li>*Throws:* `length_error` if `n > max_size()`.</li>

<li>*Effects:* Alters the length of the string designated by `*this` as follows:
<ol>

<li>— If `n <= size()`, the function replaces the string designated by
    `*this` with a string of length `n` whose elements are a copy of
    the initial elements of the original string designated by
    `*this`.</li>

<li>— If `n > size()`, the function replaces the string designated by
    `*this` with a string of length `n` whose first `size()` elements
    are a copy of the original string designated by `*this`, and whose
    remaining elements are all initialized to `c`.</li>

</ol>
</li>
</ol>

<pre highlight="">
void resize(size_type n);
</pre>
<ol start="8">
<li>*Effects:* As if by `resize(n, charT())`.</li>
</ol>

<ins>
<pre highlight="">
void resize_default_init(size_type n);
</pre>

<ol start="9">
<li> *Throws*: `length_error` if `n > max_size()`.</li>

<li>*Effects*:  Alters the length of the string designated by `*this` as follows:
<ol>

<li>If `n <= size()`, as if by `resize(n)`.</li>

<li>If `n > size()`, the function replaces the string designated by
    `*this` with a string of length `n` whose first `size()` elements
    are a copy of the original string designated by `*this`, and whose
    remaining elements are default initialized.</li>

</ol>
</li>
</ol>

</ins>
</pre>

<pre highlight="">
size_type capacity() const noexcept;
</pre>
...
</blockquote>

## [<strong>container.requirements.general</strong>] ## {#container}

In [**container.requirements.general**] [21.2.1] clarify the ambigous
"components affected by this subclause" terminology in p3. Just say
"allocator-aware containers".

<blockquote>
<ol start="3">

<li><ins>All of the containers defined in this Clause except `array` are
    allocator-aware containers.</ins> <del> For the components
    affected by this subclause that declare an allocator_type</del>
    <ins>All</ins>, objects stored in <del> these components </del>
    <ins> allocator-aware containers, except as noted, </ins> shall be
    constructed using the function
    `allocator_traits<allocator_type>::rebind_traits<U>::construct`
    and destroyed using the function
    `allocator_traits<allocator_type>::rebind_traits<U>::destroy`
    (19.10.9.2). </li>

</ol>
</blockquote>

We can then simplify p15:
<blockquote>
<ol start="15">

<li><del>All of the containers defined in this Clause and in 20.3.2
    except `array` meet the additional requirements of an
    allocator-aware container, as</del> <ins> Allocator-aware
    containers meet the additional requirements described in Table
    67.</li>

</ol>
</blockquote>


# Design Considerations # {#design}

## Method vs. Alternatives

`resize_default_init` would exposes users to UB if they read
indeterminate ([**dcl.init**] p12 (9.3.12)) values in the string.
Despite this, this approach is appealing because:

* It is simple.

* It matches existing practice. See [[#related]].

* Uninitialized buffers are not uncommon in C++. See for example `new
  T[20]` or the recently adopted `make_unique_default_init`.

* Dynamic analyzers like Memory Sanitizer [[MSan]] and Valgrind
  [[Valgrind]] can catch uninitialized reads.

During the [[SAN]] Meeting LEWG expressed a preference for
implementing this functionality as a new method on `basic_string` (as
proposed in [[P1072R0]]) rather than a standalone "storage buffer"
type (one option in [[P1072R1]]):

<blockquote>
Method on string vs storage_buffer type:
<table>
<tr><th>Strong Method</th><th>Method</th><th>Neutral</th><th>Type</th><th>Strong Type</th></tr>
<td>9</td><td>2</td><td>3</td><td>2</td><td>2</td></tr>
</table>
</blockquote>

See below for additional details on alternatives considered.


## Tag Type ## {#tag}

At the [[SAN]] Meeting, LEWG showed indifference between the
`resize_uninitialized` approach proposed in this paper and a "tag type"
style solution:

<xmp>
std::string GeneratePattern(const std::string& pattern, size_t count) {
   std::string ret;

   const auto step = pattern.size();
   // GOOD:  No initialization
   ret.resize(step * count, std::string::default_init);
   for (size_t i = 0; i < count; i++) {
     // GOOD: No bookkeeping
     memcpy(ret.data() + i * step, pattern.data(), step);
   }

   return ret;
}
</xmp>

Benefits:
*   We could invoke the constructor with the tag type as well, potentially
    simplifying code needing this functionality.

Drawbacks:
*   [[P1010R1]] contemplates initialization optimization extensions to
    `vector`.  Unlike `basic_string`, `vector` is less constrained on its
    choices of types.  The similarities in initialization are appealing,
    but there are possible pitfalls around interactions with allocators
    and the types supported (do we cover [[P0593R2]] / [[P1144R0]] /
    etc.).

## Allocator Interaction ## {#allocator}

Unlocking the desired optimizations requires *some* change to
`basic_string`'s interaction with allocators. This proposal does what
we think is the simplest possible change: remove the requirement that
`basic_string` call `allocator_traits::construct` or
`allocator_traits::destroy`.

This restriction should be acceptable because `basic_string` is
defined to only hold "non-array trivial standard-layout" types.
[[strings.general](http://eel.is/c++draft/strings.general#1)] p1:

<blockquote>

This Clause describes components for manipulating sequences of any
non-array trivial standard-layout (6.7) type. Such types are called
*char-like types*, and objects of *char-like types* are *called
char-like objects* or simply *characters*.

</blockquote>

Removing calls to `construct` and `destroy` is compatible with
`pmr::basic_string` as long as `uses_allocator_v<charT>` is `false`,
which should be the case in practice.

Along the way, this proposal clarifies ambigous language in
[**string.require**] and [**container.requirements.general**] by:

* Stating explicitly that `basic_string` is allocator-aware.

* Introducing the term "allocator-aware" earlier in
  [**container.requirements.general**].

* Not attempting to mention other "components" in
  [**container.requirements.general**]. The other allocator aware
  containers (just `basic_string` and `regex::match_results`?) can
  independently state that they are "allocator-aware" in their own
  clauses.


## Bikeshedding ## {#bikeshed}

What do we want to call this method?

*   `resize_default_init` (as proposed). Consistent with [[P1020R1]], adopted in San Diego Meeting.
*   `resize_uninitialized` (as proposed in R0)

# Alternatives Considered # {#alternatives}

## Standalone Type:  `storage_buffer` ## {#buffer}

In [[P1072R1]], we considered `storage_buffer`, a standalone type
providing a `prepare` method (similar to the `resize_uninitialized` method
proposed here) and `commit` (to promise, under penalty of UB, that the
buffer had been initialized).

At the [[SAN]] Meeting, this approach received support from LEWGI in
light of the the [[post-Rapperswil]] email review indicating support for a
distinct type.  This approach was rejected by the larger LEWG room in San Diego Meeting
Diego.


The proposed type would be move-only.

<xmp>
std::string GeneratePattern(const std::string& pattern, size_t count) {
   std::storage_buffer<char> tmp;

   const auto step = pattern.size();
   // GOOD:  No initialization
   tmp.prepare(step * count + 1);
   for (size_t i = 0; i < count; i++) {
     // GOOD: No bookkeeping
     memcpy(tmp.data() + i * step, pattern.data(), step);
   }

   tmp.commit(step * count);
   return std::string(std::move(tmp));
}
</xmp>

For purposes of the container API, `size()` corresponds to the *committed*
portion of the buffer.  This leads to more consistency when working with (and
explicitly copying to) other containers via iterators, for example:

<xmp>
    std::storage_buffer<char> buf;
    buf.prepare(100);
    *fill in data*
    buf.commit(50);

    std::string a(buf.begin(), buf.end());
    std::string b(std::move(buf));

    assert(a == b);
</xmp>

Benefits:
*   By being move-only, we would not have the risk of copying types with
    trap representations (thereby triggering UB).
*   Uninitialized data is only accessible from the `storage_buffer` type.
    For an API working with `basic_string`, no invariants are weakened.
    Crossing an API boundary with a `storage_buffer` is much more obvious than
    a "`basic_string` with possibly uninitialized data."  Uninitialized bytes
    (the promise made by `commit`) never escape into the valid range of
    `basic_string`.

Drawbacks:
*   `storage_buffer` requires introducing an extra type to the standard
    library, even though its novel functionality (from `string` and
    `vector`) is limited to the initialization abilities.
*   `basic_string` is often implemented with a short-string optimization (SSO) and an extra type would need to implement that (likely by additional checks when moving to/from the `storage_buffer`) that are often unneeded.

## Externally-Allocated Buffer Injection ## {#external}

We asked whether we should accept an externally allocated and initialized `T*`
and place it into a `basic_string`.  At the [[SAN]] Meeting, we concluded that
this was:

*  **Not critical**
*  **Not constrained in the future**
*  **Could overly constrain implementers**.  Allowing users to provide their own `allocator::allocate`'d buffers runs into the "offset problem".  Consider an implementation that stores its `size` and `capacity` inline with its data, so `sizeof(vector) == sizeof(void*)`.

    <xmp>
    class container {
      struct Rep {
        size_t size;
        size_t capacity;
      };

      Rep* rep_;
    };
    </xmp>

    If using a `Rep`-style implementation, the mismatch in offsets
    requires an O(N) move to shift the contents into place and trigger a
    possible reallocation.

*  **Have usage pitfalls**.  It would be easy to mix `new[]` and `allocator::deallocate` inadvertently:

    <xmp>
    std::string GeneratePattern(const std::string& pattern, size_t count) {
        const auto step = pattern.size();

        // GOOD:  No initialization
        std::string ret;
        ret.reserve(step * count);

        auto tmp = ret.release();

        char* start = tmp.data();
        auto  size  = tmp.size();
        auto  cap   = tmp.capacity();
        tmp.release();

        for (size_t i = 0; i < count; i++) {
            // GOOD: No bookkeeping
            memcpy(start + i * step, pattern.data(), step);
        }

        return std::string(std::storage_node(
            tmp, size + count * step, cap, alloc));
    }
    </xmp>

    (It is important to reiterate that the above implementation is possible
    because we statically know that the allocator is `std::allocator` and that
    the `value_type` is `char`. A generic implementation of this pattern would
    need to be constrained based on allocators, allocator traits, and value
    types. Future library and language extensions may expand the set of
    applicable types and may make it easier to constrain generic
    implementations.)

# Related Work # {#related}

## Google ## {#google}

Google has a local extension to `basic_string` called `resize_uninitialized`
and is wrapped as `STLStringResizeUninitialized`.

*   [[Abseil]] uses this to avoid bookkeeping overheads in `StrAppend` and
    `StrCat`.
*   [[Snappy]]

    *   In <a href="https://github.com/google/snappy/blob/master/snappy.cc#L1318">decompression</a>, the final size of the output buffer is known before the contents are ready.
    *   During <a href="https://github.com/google/snappy/blob/master/snappy.cc#L1386">compression</a>, an upperbound on the final compressed size is known, allowing data to be efficiently added to the output buffer (eliding `append`'s checks) and the string to be shrunk to its final, correct size.

*   [[Protobuf]] avoids extraneous copies or initialization when the
    size is known before data is available (especially during parsing or
    serialization).

## MongoDB ## {#mongodb}

MongoDB has a string builder that could have been implemented in terms of
`basic_string` as a return value. However, as explained by Mathias Stearn, zero
initialization was measured and was too costly. Instead a custom string builder
type is used:

E.g.: <a
href="https://github.com/mongodb/mongo/blob/67da083face9dabdf95a5ffb72d3da675269b4c7/src/mongo/db/fts/unicode/string.h#L128-L143">
https://github.com/mongodb/mongo/blob/master/src/mongo/db/fts/unicode/string.h
</a>

<xmp>
/**
 * Strips diacritics and case-folds the utf8 input string, as needed to support
 * options.
 *
 * The options field specifies what operations to *skip*, so kCaseSensitive
 * means to skip case folding and kDiacriticSensitive means to skip diacritic
 * striping. If both flags are specified, the input utf8 StringData is returned
 * directly without any processing or copying.
 *
 * If processing is performed, the returned StringData will be placed in
 * buffer.  buffer's contents (if any) will be replaced. Since we may return
 * the input unmodified the returned StringData's lifetime is the shorter of
 * the input utf8 and the next modification to buffer. The input utf8 must not
 * point into buffer.
 */
static StringData caseFoldAndStripDiacritics(StackBufBuilder* buffer,
                                             StringData utf8,
                                             SubstrMatchOptions options,
                                             CaseFoldMode mode);
</xmp>
(Comments re-wrapped.)

## VMware ## {#vmware}

VMware has an internal string builder implementation that avoids `std::string`
due, in part, to `reserve`'s zero-writing behavior. This is similar in spirit to
the MongoDB example above.

## Discussion on std-proposals ## {#std}

This topic was discussed in 2013 on std-proposals in a thread titled "Add
basic_string::resize_uninitialized (or a similar mechanism)":</br> <a
href="https://groups.google.com/a/isocpp.org/forum/#!topic/std-proposals/XIO4KbBTxl0">
https://groups.google.com/a/isocpp.org/forum/#!topic/std-proposals/XIO4KbBTxl0</a>

## DynamicBuffer ## {#dynamicbuffer}

The [[N4734]] (the Networking TS) has *dynamic buffer* types.

## P1020R0 ## {#p1020}

See also [[P1020R0]] "Smart pointer creation functions for default
initialization".

## Boost ## {#boost}

Boost provides a related optimization for vector-like containers,
introduced in <a
href="https://github.com/boostorg/container/commit/14f092ab00def8e692b81d57d0466a617a6f6130">
[SVN r85964] </a> by Ion Gaztañaga.

E.g.: <a
href="https://github.com/boostorg/container/blob/develop/include/boost/container/vector.hpp">
boost/container/vector.hpp</a>:

<xmp>
   //! <b>Effects</b>: Constructs a vector that will use a copy of allocator a
   //!   and inserts n default initialized values.
   //!
   //! <b>Throws</b>: If allocator_type's allocation
   //!   throws or T's default initialization throws.
   //!
   //! <b>Complexity</b>: Linear to n.
   //!
   //! <b>Note</b>: Non-standard extension
   vector(size_type n, default_init_t);
   vector(size_type n, default_init_t, const allocator_type &a)
   ...
   void resize(size_type new_size, default_init_t);
   ...
</xmp>

These optimizations are also supported in Boost Container's `small_vector`,
`static_vector`, `deque`, `stable_vector`, and `string`.

# Questions for LEWG # {#questions}

1.  Is LEWG satisified with this approach?

# History # {#history}

## R1 &rarr; R2 ## {#R2}

Applied feedback from [[SAN]] Meeting reviews.

*   Reverted design to "option A" proposed in [[P1072R0]]
*   Added discussion of alternatives considered

## R0 &rarr; R1 ## {#R1}

Applied feedback from LEWG [[post-Rapperswil]] Email Review:

*   Shifted to a new vocabulary types: `storage_buffer` / `storage_node`

    *   Added presentation of `storage_buffer` as a new container type
    *   Added presentation of `storage_node` as a node-like type

*   Added discussion of design and implementation considerations.

*   Most of [[P1010R1]] Was merged into this paper.

<pre class=biblio>
{
    "Abseil": {
        "href": "https://github.com/abseil/abseil-cpp",
        "date": "2018-09-22",
        "title": "Abseil"
    },
    "SAN": {
        "href": "http://wiki.edg.com/bin/view/Wg21sandiego2018/P1072",
	"date": "2018-11-07",
	"title": "San Diego Meeting Minutes"
    },
    "post-Rapperswil": {
        "href": "http://lists.isocpp.org/lib-ext/2018/08/8299.php",
        "date": "2018-08-26",
        "title": "LEWG Weekly - P1072"
    },
    "N4734": {
        "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4734.pdf",
        "date": "2018-04-04",
        "title": "Working Draft, C++ Extensions for Networking"
    },
    "N4762": {
        "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4762.pdf",
        "date": "2018-07-07",
        "title": "Working Draft, Standard for Programming Language C++"
    },
    "N4778": {
        "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4762.pdf",
        "date": "2018-07-07",
        "title": "Working Draft, Standard for Programming Language C++"
    },

    "P0083R3": {
        "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0083r3.pdf",
        "date": "2016-06-24",
        "title": "Splicing Maps and Sets"
    },
    "P0593R2": {
        "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0593r2.html",
        "date": "2018-02-11",
        "title": "Implicit creation of objects for low-level object manipulation"
    },
    "P1010R1": {
        "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1010r1.html",
        "date": "2018-10-08",
        "title": "Container support for implicit lifetime types."
    },
    "P1020R0": {
        "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1020r0.html",
        "date": "2018-04-08",
        "title": "Smart pointer creation with default initialization"
    },
    "P1020R1": {
	"href": "https://wg21.link/P1020R1",
	"date": "2018-11-06",
	"title": "Smart pointer creation with default initialization"
    },
    "P1072R0": {
        "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1072r0.html",
        "date": "2018-05-04",
        "title": "Default Initialization for basic_string"
    },
    "P1072R1": {
        "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1072r1.html",
        "date": "2018-10-07",
        "title": "Optimized Initialization for basic_string and vector"
    },
    "P1144R0": {
        "href": "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1144r0.html",
        "date": "2018-10-04",
        "title": "Object relocation in terms of move plus destroy"
    },
    "Protobuf": {
        "href": "https://github.com/protocolbuffers/protobuf",
        "date": "2018-09-22",
        "title": "Protocol Buffers"
    },
    "Snappy": {
        "href": "https://github.com/google/snappy",
        "date": "2018-09-21",
        "title": "Snappy"
    },
    "MSan": {
        "href": "https://clang.llvm.org/docs/MemorySanitizer.html",
        "title": "Memory Sanitizer"
    },
    "Valgrind": {
        "http://www.valgrind.org",
        "title": "Valgrind"
    }
}
</pre>
